## Dependencies
import math
from time import time
import numpy as np
from TreeNode import TreeNode
from state import state_handler
import random


def monte_carlo_tree_search(root: TreeNode, state_handler: state_handler, max_itr=0, max_time=0) -> TreeNode:
    """
    Runs the monte carlo tree search algorithm.
    If max_itr is 0, it will run until max_time is reached, else it will run for max_itr iterations.
    Returns the root node of the tree generated with the given root.
    """
    if max_itr == 0:
        start_time = time.time()
        while time.time() - start_time < max_time:
            choosen_node: TreeNode = selection(root)
            created_node = expansion(choosen_node, state_handler)
            result = simulation(created_node)
            backpropergation(created_node, result)
    else:
        itr = 0
        while itr < max_itr:
            choosen_node: TreeNode = selection(root)
            created_node = expansion(choosen_node, state_handler)
            result = simulation(created_node)
            backpropergation(created_node, result)
            itr += 1

    return root

def selection(node: TreeNode):
    '''
    This selects the best leaf for expansion.
    For Monte Carlo this is the node that you should expand.
    Given by exploration and exploitation means.
    '''
    child_nodes = node.get_children()
    best_child = None
    best_node_value = 0

    while child_nodes:
        for child_node in child_nodes:
            if (best_node_value < ucb(child_node)):
                best_child = child_node
                best_node_value = ucb(child_node)
        return selection(best_child)
    return node


def expansion(node: TreeNode, state_handler: state_handler):
    """
    Generates a new child to node. It is generated by making a random move, 
    checking if that move has a corresponding child, if not it generates a child with the random move.
    Repeats until a child is generated
    """
    while True:

        generate = True
        legal_actions = state_handler.get_legal_actions(node)

        if len(legal_actions) == len(node.get_children()):
            # all legal actions have already been explored
            break

        if generate:
            new_node = TreeNode(state = None, parent = node)
            node.add_child(new_node) 
            break

def choose_move(legal_actions: list):
    """"
    Takes in legal moves an chooses one of them at random
    """
    index = random.randint(0, len(legal_actions)-1)
    move = legal_actions[index]
    return move

def simulation(node: TreeNode) -> int:
    """
    In this process, a simulation is performed by choosing moves or strategies until a result or predefined state is achieved.
    """
    state = node.get_state()
    while state.is_finished():
        legal_action = state_handler.get_legal_actions()
        state.move(choose_move(legal_action)) # TODO refactor
    
    return state.get_winner()

def backpropergation(node: TreeNode, result: int) -> None:
    """
    After determining the value of the newly added node, the remaining tree must be updated. 
    So, the backpropagation process is performed, where it backpropagates from the new node to the root node. 
    During the process, the number of simulation stored in each node is incremented. Also, if the new nodeâ€™s 
    simulation results in a win, then the number of wins is also incremented.
    """
    node.add_visits()
    node.add_reward(result)
    if not node.is_root(): #if node is not root, then it has a parent and backpropagates to it
        backpropergation(node.get_parent(), -result)
    
def upper_condidence_bound(empiricalMean: float, visitationOfParentNode: int, visitationOfChildNode: int ) -> float:
    constant = math.sqrt(2)
    exploredness = math.sqrt(math.log(visitationOfParentNode)/visitationOfChildNode)
    return empiricalMean + constant * exploredness
 
def ucb(node: TreeNode):
    """
    Takes in node and returns upper confidence bound based on parent node visits and node visits
    """
    exploration_parameter = math.sqrt(2)
    exploitation = node.get_wins()/node.get_visits()
    exploration = np.sqrt(np.log(node.get_parent().get_visits())/node.get_visits())
    return exploitation + exploration_parameter*exploration


if __name__ == "__main__":

    def setup_test_tree():
        root_node = TreeNode("1")
        root_node._wins = 11
        root_node._visits = 21 

        
        wanted_node1 = TreeNode("2", root_node)
        wanted_node1._wins = 7
        wanted_node1._visits = 10 

        wanted_node2 = TreeNode("3", root_node)
        wanted_node2._wins = 3
        wanted_node2._visits = 8 


        wanted_node4 = TreeNode("4", wanted_node1)
        wanted_node4._wins = 2
        wanted_node4._visits = 4 

        wanted_node5 = TreeNode("5", wanted_node1)
        wanted_node5._wins = 1
        wanted_node5._visits = 6


        wanted_node6 = TreeNode("6", wanted_node5)
        wanted_node6._wins = 2
        wanted_node6._visits = 3


        wanted_node7 = TreeNode("7", wanted_node5)
        wanted_node7._wins = 3
        wanted_node7._visits = 3
        return root_node

    def selection_test():
        root_node = TreeNode("1")
        root_node._wins = 11
        root_node._visits = 21 

        
        wanted_node1 = TreeNode("2", root_node)
        wanted_node1._wins = 7
        wanted_node1._visits = 10 

        wanted_node2 = TreeNode("3", root_node)
        wanted_node2._wins = 3
        wanted_node2._visits = 8 


        wanted_node4 = TreeNode("4", wanted_node1)
        wanted_node4._wins = 2
        wanted_node4._visits = 4 

        wanted_node5 = TreeNode("5", wanted_node1)
        wanted_node5._wins = 1
        wanted_node5._visits = 6


        wanted_node6 = TreeNode("6", wanted_node5)
        wanted_node6._wins = 2
        wanted_node6._visits = 3


        wanted_node7 = TreeNode("7", wanted_node5)
        wanted_node7._wins = 3
        wanted_node7._visits = 3

        selcted_node = selection(root_node)
        print(selcted_node.get_state())

    def node_expantion_test():
        pass
    def test_selection():
        # create parent node
        parent_node = TreeNode(state=None)
        # create child nodes with different rewards
        child1 = TreeNode(state=None, parent=parent_node)
        child1.set_wins(2)
        child1.set_visits(3)
        child2 = TreeNode(state=None, parent=parent_node)
        child2.set_wins(4)
        child2.set_visits(5)
        child3 = TreeNode(state=None, parent=parent_node)
        child3.set_wins(1)
        child3.set_visits(2)
        # perform selection
        best_child = selection(parent_node)
        # assert that the best child is child2 with the highest UCB score
        assert best_child == child2
    ### CALL TESTS
    test_selection()


        



        
